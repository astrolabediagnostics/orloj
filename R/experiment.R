# experiment.R
# Functions for interacting with Astrolabe experiments.

#' Load Astrolabe experiment.
#'
#' Load an Astrolabe experiment which can then be used for other orloj
#' functions. As part of loading the experiment, correct the file paths that
#' were generated by the Astrolabe platform to local file paths.
#'
#' @param experiment_path Path to the Astrolabe experiment.
#' @return Astrolabe experiment.
#' @export
loadExperiment <- function(experiment_path) {
  experiment <- readRDS(file.path(experiment_path, "config.RDS"))

  experiment$analysis_path <- file.path(experiment_path, "analysis")
  experiment$reports_path <- file.path(experiment_path, "reports")
  experiment$samples_path <- file.path(experiment_path, "samples")

  experiment
}

#' Get experiment sample features.
#'
#' Get the sample features for a given Astrolabe experiment. Feature names are
#' converted from internal Astrolabe IDs to user-readable names.
#'
#' @param experiment An Astrolabe experiment.
#' @return Experiment sample features.
#' @export
getExperimentSampleFeatures <- function(experiment) {
  sample_features <- experiment$sample_features
  features <- experiment$features

  # Experiment has no features, return just column with sample IDs.
  if (ncol(features) == 0) return(experiment$samples[, "SampleId"])

  features$FeatureId <- paste0("feature_", features$FeatureId)
  m <- match(colnames(sample_features), features$FeatureId)
  col_indices <- !is.na(m)
  colnames(sample_features)[col_indices] <- features$FeatureName[m[col_indices]]

  sample_features
}

#' Astrolabe experiment summary.
#'
#' @param experiment An Astrolabe experiment.
#' @export
experimentSummary <- function(experiment) {
  cat(paste0(
    "Astrolabe experiment with ",
    nrow(experiment$samples), " samples and ",
    nrow(experiment$channels), " channels\n\n"
  ))
  cat(paste0(
    "Classification channels:\n",
    paste(experiment$class_channels, collapse = ", "),
    "\n"
  ))
  if (nrow(experiment$features) > 0) {
    cat("\n")
    cat("Sample features:\n")
    for (row_idx in seq(nrow(experiment$features))) {
      row <- experiment$features[row_idx, ]
      feature_id <- paste0("feature_", row$FeatureId)
      feature_values <- unique(experiment$sample_features[[feature_id]])
      cat(paste0(
        row$FeatureName, ": ", paste(feature_values, collapse = ", "), "\n"))
    }
  }
}

.chooseLevel <- function(experiment) {
  # Choose default level for experiment.
  if (is.null(experiment$organism)) {
    return("Assignment")
  } else if (experiment$organism == "profiling_only") {
    return("Profiling")
  } else {
    return("Assignment")
  }
}

#' Experiment cell subset counts.
#'
#' Cell subset counts and frequencies for all of the samples in an experiment.
#'
#' @param experiment An Astrolabe experiment.
#' @param level Cell subset level. Currently supported levels are "Assignment"
#' and "Profiling". The default is "Profiling" for Profiling Only experiments
#' and "Assignment" otherwise.
#' @return Cell subset counts for that level.
#' @export
experimentCellSubsetCounts <- function(experiment,
                                       level = .chooseLevel(experiment)) {
  if (!(level %in% c("Assignment", "Profiling"))) {
    stop('level is not "Assignment" or "Profiling"')
  }
  if (level == "Profiling") level = "Profile"

  aggregate_statistics_filename <-
    file.path(experiment$analysis_path, "combine_aggregate_statistics.RDS")
  if (!file.exists(aggregate_statistics_filename)) {
    stop(paste0(aggregate_statistics_filename, "not found"))
  }
  aggregate_statistics <- readRDS(aggregate_statistics_filename)

  counts <- aggregate_statistics$subset_cell_counts
  if (!(level %in% counts$Parent)) {
    stop("level not found in cell subset counts")
  }

  counts <- counts %>%
    dplyr::filter(Parent == level) %>%
    dplyr::select(-Parent)
  counts <- dplyr::left_join(experiment$samples, counts, by = "SampleId")

  # Calculate frequencies.
  counts <- counts %>%
    dplyr::group_by(SampleId) %>%
    dplyr::mutate(Freq = N / sum(N)) %>%
    dplyr::ungroup()

  counts
}

#' Experiment cell subset channel statistics.
#'
#' Cell subset channel statistics for all of the samples in an experiment.
#'
#' @param experiment An Astrolabe experiment.
#' @param level Cell subset level. Currently supported levels are "Assignment"
#' and "Profiling". The default is "Profiling" for Profiling Only experiments
#' and "Assignment" otherwise.
#' @return Cell subset channel statistics for that level.
#' @export
experimentCellSubsetChannelStatistics <- function(experiment,
                                                  level = .chooseLevel(experiment)) {
  if (!(level %in% c("Assignment", "Profiling"))) {
    stop("level is not \"Assignment\" or \"Profiling\"")
  }
  if (level == "Profiling") level = "Profile"

  aggregate_statistics_filename <-
    file.path(experiment$analysis_path, "combine_aggregate_statistics.RDS")
  if (!file.exists(aggregate_statistics_filename)) {
    stop(paste0(aggregate_statistics_filename, "not found"))
  }
  aggregate_statistics <- readRDS(aggregate_statistics_filename)

  stats <- aggregate_statistics$subset_channel_statistics
  if (!(level %in% stats$Parent)) {
    stop("level not found in cell subset channel statistics")
  }

  stats <- stats %>%
    dplyr::filter(Parent == level) %>%
    dplyr::select(-Parent)
  stats <- dplyr::left_join(experiment$samples, stats, by = "SampleId")

  stats
}

#' Map experiment cell subsets to numerical values.
#'
#' Create a map from experiment cell subsets in a given level to unique
#' numerical values. This map is used when generating Assignment and Profiling
#' columns in exported FCS files.
#'
#' @param experiment An Astrolabe experiment.
#' @param level Cell subset level. Currently supported levels are "Assignment"
#' and "Profiling". The default is "Profiling" for Profiling Only experiments
#' and "Assignment" otherwise.
#' @return Map from cell subsets to numerical values.
#' @export
experimentCellSubsetMap <- function(experiment,
                                    level = .chooseLevel(experiment)) {
  if (level == "Profiling") level <- "Profile"

  # Get cell subsets from aggregate statistics.
  aggregate_statistics_filename <-
    file.path(experiment$analysis_path, "combine_aggregate_statistics.RDS")
  if (!file.exists(aggregate_statistics_filename)) {
    stop(paste0(aggregate_statistics_filename, " not found"))
  }
  aggregate_statistics <- readRDS(aggregate_statistics_filename)
  stats <- aggregate_statistics$subset_channel_statistics
  if (!(level %in% stats$Parent)) {
    stop("level not found in cell subset channel statistics")
  }
  cell_subsets <- unique(stats$CellSubset[stats$Parent == level])

  # If assignment level, complete the list with any subsets that could have
  # occurred but did not.
  if (level == "Assignment") {
    cell_subsets <- union(cell_subsets, experimentAssignmentSubsets(experiment))
  }
  
  cell_subsets <- gtools::mixedsort(cell_subsets)

  # Add beads, debris, and dead cells.
  cell_subsets <- c(cell_subsets, "AstrolabeBead", "Debris", "Dead")

  data.frame(
    Value = seq(length(cell_subsets)),
    CellSubset = cell_subsets,
    stringsAsFactors = FALSE
  )
}

#' Differential abundance analysis.
#'
#' Load the experiment differential abundance analysis, for a given cell subset
#' level.
#'
#' @param experiment An Astrolabe experiment.
#' @param level Cell subset level. Currently supported levels are "Assignment"
#' and "Profiling".
#' @param convert_ids Whether to convert Astrolabe IDs to feature names.
#' @return Differential abundance analysis list.
#' @export
differentialAbundanceAnalysis <- function(experiment,
                                          level = .chooseLevel(experiment),
                                          convert_ids = TRUE) {
  if (!(level %in% c("Assignment", "Profiling"))) {
    stop("level is not \"Assignment\" or \"Profiling\"")
  }

  # Value for NA feature value. Samples with this value should not be included
  # in the analysis.
  feature_na <- "__NA__"

  daa_filename <-
    file.path(experiment$analysis_path, "differential_abundance_analysis.RDS")
  if (!file.exists(daa_filename)) {
    stop(paste0(daa_filename, " not found"))
  }
  differential_abundance_analysis <- readRDS(daa_filename)

  daa <- differential_abundance_analysis$differential_abundance_analysis

  if (!(level %in% names(daa))) {
    return(NULL)
  }
  daa <- daa[[level]]

  # Find feature values.
  feature_values <- lapply(nameVector(names(daa)), function(feature_name) {
    values <- unique(experiment$sample_features[[feature_name]])
    values <- setdiff(values, feature_na)
    values
  })
  # Convert feature IDs to names.
  if (convert_ids) {
    m <-
      match(as.numeric(gsub("^feature_", "", names(daa))),
            experiment$features$FeatureId)
    names(daa) <- experiment$features$FeatureName[m]
    names(feature_values) <- experiment$features$FeatureName[m]
  }

  # Convert tables to tibbles and only keep p-value, FDR, and logFC.
  lapply(nameVector(names(daa)), function(feature_name) {
    if (is.null(daa[[feature_name]])) {
      NULL
    } else {
      tab <- as.data.frame(daa[[feature_name]]) %>%
        tibble::rownames_to_column("CellSubset")

      # Calculate max(logFC) for features with multiple values.
      log_fc_cols <- grep("logFC", colnames(tab))
      if (length(log_fc_cols) > 1) {
        log_fc <- tab[, log_fc_cols]
        max_log_fc <- apply(log_fc, 1, function(v) v[which.max(abs(v))])
        tab$logFC <- max_log_fc
      }

      cols <-
        c("CellSubset",
          "logFC",
          "PValue",
          "FDR",
          paste0("median_", feature_values[[feature_name]]))
      
      tab[, cols]
    }
  })
}

#' MDS map.
#'
#' Return the MDS map for the experiment, for a given level.
#'
#' @param experiment An Astrolabe experiment.
#' @param level Cell subset level. Currently supported levels are "Assignment"
#' and "Profiling".
#' @param convert_ids Whether to convert Astrolabe IDs to feature names.
#' @return MDS map.
#' @export
experimentMds <- function(experiment,
                          level = .chooseLevel(experiment),
                          convert_ids = TRUE) {
  if (!(level %in% c("Assignment", "Profiling"))) {
    stop("level is not \"Assignment\" or \"Profiling\"")
  }

  mds_filename <-
    file.path(experiment$analysis_path, "calculate_mds.RDS")
  if (!file.exists(mds_filename)) {
    stop(paste0(mds_filename, " not found"))
  }
  mds <- readRDS(mds_filename)

  mds <- mds[[level]]

  # Calculate and add mean frequency over all samples.
  cell_subset_counts <- experimentCellSubsetCounts(experiment, level = level)
  mds_freqs <- cell_subset_counts %>%
    dplyr::group_by(CellSubset) %>%
    dplyr::summarize(Freq = mean(Freq))
  mds <- dplyr::left_join(mds, mds_freqs, by = "CellSubset")

  # Calculate and add mean marker intensities over all samples.
  marker_stats <-
    experimentCellSubsetChannelStatistics(experiment, level = level)
  marker_stats <- marker_stats %>%
    dplyr::group_by(CellSubset, ChannelName) %>%
    dplyr::summarize(Median = mean(Median)) %>%
    reshape2::dcast(CellSubset ~ ChannelName, value.var = "Median")
  mds <- dplyr::left_join(mds, marker_stats, by = "CellSubset")

  # Add max(fold change) and -log10(FDR) for each feature.
  daa <- differentialAbundanceAnalysis(experiment, level = level, convert_ids)
  for (feature_name in names(daa)) {
    # Skip features for which we did not run DAA.
    if (is.null(daa[[feature_name]])) next

    tab <- daa[[feature_name]]
    tab <- tab[, c("CellSubset", "logFC", "FDR")]
    colnames(tab) <-
      c("CellSubset",
        paste0(feature_name, "_logFC"),
        paste0(feature_name, "_FDR"))
    mds <- dplyr::left_join(mds, tab, by = "CellSubset")
  }

  mds
}


#' Experiment Assignment labeling strategy.
#'
#' Return a user-readable table of the labeling strategy for the Assignment
#' level.
#' @param experiment An Astrolabe experiment.
#' @return User-readable table of the experiment hierarchy.
#' @export
experimentLabelingStrategy <- function(experiment) {
  if (experiment$organism == "profiling_only") return (NULL)
  
  hierarchy <-
    readRDS(file.path(experiment$analysis_path, "hierarchy.RDS"))$hierarchy

  # Convert Assignment cell subsets to strings.
  assignment <- setdiff(hierarchy$CellSubset, hierarchy$Parent)
  descs <- lapply(orloj::nameVector(assignment), function(cell_subset) {
    channels <-
      .getSubsetChannelsFull(hierarchy, experiment$class_channels, cell_subset)
    data.frame(
      CellSubset = cell_subset,
      Desc = .convertChannelsToDesc(channels),
      stringsAsFactors = FALSE
    )
  }) %>% dplyr::bind_rows()

  # Order according to Level_1 order.
  level_ones <- lapply(orloj::nameVector(assignment), function(cell_subset) {
    curr_subset <- cell_subset
    while (curr_subset != "Root") {
      curr_subset <- gsub("_unassigned", "", curr_subset)
      parent <- curr_subset
      curr_subset <- hierarchy$Parent[hierarchy$CellSubset == curr_subset]
    }
    
    data.frame(
      Parent = parent,
      CellSubset = cell_subset,
      stringsAsFactors = FALSE
    )
  }) %>% dplyr::bind_rows()
  level_ones <- level_ones[gtools::mixedorder(level_ones$Parent), ]

  dplyr::left_join(level_ones, descs, by = "CellSubset")
}

.getSubsetChannels <- function(hierarchy, class_channels, cell_subset) {
  # Get data frame with state of each channel for given subset.
  hierarchy <- hierarchy[hierarchy$CellSubset == cell_subset, ]
  channels <-
    intersect(class_channels, names(which(colSums(!is.na(hierarchy)) > 0)))
  hierarchy <- hierarchy[, channels, drop = FALSE]
  hierarchy$CellSubset <- cell_subset
  ch <-
    reshape2::melt(hierarchy, id.vars = "CellSubset", variable.name = "Channel",
                   value.name = "State")
  ch$Channel <- as.character(ch$Channel)
  ch[gtools::mixedorder(ch$Channel), ]
}

.getSubsetChannelsFull <- function(hierarchy, class_channels, cell_subset) {
  # Get data frame with state of each channel for given subset, spanning the
  # entire hierarchy.
  df <- data.frame()
  while (cell_subset != "Root") {
    cell_subset <- gsub("_unassigned", "", cell_subset)
    df <- rbind(.getSubsetChannels(hierarchy, class_channels, cell_subset), df)
    cell_subset <- hierarchy$Parent[hierarchy$CellSubset == cell_subset]
  }
  df
}

.convertChannelsToDesc <- function(channels) {
  # Convert channels data frame to a string.
  channels$StateStr <- ifelse(channels$State, "+", "-")
  # Use factors to maintain subset order.
  channels$CellSubset <-
    factor(channels$CellSubset, levels = unique(channels$CellSubset))
  channels <- channels %>%
    dplyr::group_by(CellSubset) %>%
    dplyr::summarize(Str = paste0(paste0(Channel, StateStr), collapse = " "))
  paste0(channels$Str, collapse = ", ")
}

#' List of Assignment subsets.
#'
#' Return a vector of all Assignment subsets.
#''
#' @param experiment An Astrolabe experiment.
#' @return Character vector of Assignment subsets.
#' @export
experimentAssignmentSubsets <- function(experiment) {
  if (experiment$organism == "profiling_only") return(NULL)
  
  subsets <- experimentLabelingStrategy(experiment)$CellSubset
  
  if (!is.null(experiment$extend_assignment_unassigned) &&
      experiment$extend_assignment_unassigned) {
    hierarchy <-
      readRDS(file.path(experiment$analysis_path, "hierarchy.RDS"))$hierarchy
    
    subsets <- c(subsets, paste0(unique(hierarchy$Parent), "_unassigned"))
  }
  
  gtools::mixedsort(subsets)
}

